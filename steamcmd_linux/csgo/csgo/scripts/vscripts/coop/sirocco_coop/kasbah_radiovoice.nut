//debug stuff
debug <- false	//Set true to enable debug block during think function
debugInterval <- 3.00

lastthink <- Time()
startBlock <- 0

//Queue of scenes started with PlayVcd()
scenequeue <- {}
firedfromqueue <- false

//Map Name
curMapName <- GetMapName()


//Include the autogenerated scene table
DoIncludeScript( "coop/sirocco_coop/kasbahradio_scenetable_include", self.GetScriptScope() )




function printldebug(arg)
{
	if (debug)
	{
		printl(arg)
	}
}


// -------------------------------------------------------------------
// Precache sounds we will emit
// Define like this: self.PrecacheSoundScript( "Your.SoundName" )
//
// Then you call the sound like so:
// self.EmitSound("Your.SoundName")
// -------------------------------------------------------------------
function Precache()
{              

}

// OnPostSpawn - this is all the initial setup stuff
function OnPostSpawn()
{
//		if (self.GetName() == "@franz")
//		{
//		printl ("                                                  HELLO MY NAME IS FRANZ");
//		DoIncludeScript( "coop/sirocco_coop/kasbahradio_scenetable_include_franz", self.GetScriptScope() )
//		}
		
//		if (self.GetName() == "@radiovoice")
//		{
//		printl ("                                                  HELLO MY NAME IS FELIX");
//		DoIncludeScript( "coop/sirocco_coop/kasbahradio_scenetable_include_felix", self.GetScriptScope() )
//		}

		printl("===========================POST SPAWN!=======")
		local i = 0
		//assign a unique id to each scene entity (uses SetTeam because that's the only thing available)
		foreach (val in SceneTable)
		{
			i+=1
			val.vcd.ValidateScriptScope()
			val.vcd.SetTeam(i)
			val.index <- i
		}		
		//Initialize the deferred scene queue
		//QueueInitialize()
		//PuzzlePreStart()
		PostSpawnString <- "POSTSPAWN!!!"
		
		
}

//Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the correct SceneTable index for that entry
//ex: SceneTableInst = SceneTable[findIndex(team)]
function findIndex(team)
{
		local idx, val
		foreach (idx, val in SceneTable)
		{
			if (val.index == team)
			{
				return idx
			}
		}
		return null
}

//Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the scene instance that originally fired it.
//Unfortunately, if multiple scene instances fire the same vcd, this isn't reliable. Hopefully we can either a) fix that 
//or b) not have multiple scene instances use the same vcd (which is currently the case as of 07/19/2010 - efw)
function FindSceneInstanceByTeam(team)
{
	local idx, val
	local idx2, val2
	local inst = null
	foreach (idx, val in scenequeue)
	{
		foreach (idx2, val2 in val.waitFiredVcds)
		{
			if (val2 == team)
			{
				inst = val
				break
			}
		}
		if (inst != null)
			break
	}
	return inst
}


//Is a character currently playing an uninterruptible scene?
//char = character name string
function IsCharPlayingUninterruptibleScene(char)
{
	local idx, val
	foreach (idx, val in scenequeue)
	{
		if (val.currentCharacter==char && val.waitUninterruptible)
		{
			return true
		}
	}
	return false
}


function SceneCanceled()
{
	printldebug("========SCENE CANCELLED - CALLING ENTITY: "+findIndex(owninginstance.GetTeam()))
}

//If a vcd is tagged to "exit early" (by setting postdelay < 0), this event fires rather than PlayNextScene() when the vcd finishes.
//SkipOnCompletion() has all the functionality of PlayNextScene(), except it doesn't actually play the next scene, because the next scene presumably
//already started playing when the vcd exited early.
//SkipOnCompletion does, however, evaluate the vcd's SceneTable entry to see if any EntFires need to happen.
function SkipOnCompletion()
{
	printldebug("========SKIPONCOMPLETION CALLING ENTITY: "+findIndex(owninginstance.GetTeam())+" : TIME "+Time())
	local team = owninginstance.GetTeam()
	local inst = FindSceneInstanceByTeam(team)
	if (inst != null)
	{
		inst.deleteFiredVcd(team)
		inst.waitVcdCurrent = findIndex(team)
		//Are there any EntFires associated with this vcd?
		if (inst.waitVcdCurrent != null)
		{
			if ("fires" in SceneTable[inst.waitVcdCurrent])
			{
				local idx, val
				foreach (idx, val in SceneTable[inst.waitVcdCurrent].fires)
				{
					if (!("fireatstart" in val))
					{
						printldebug(">>>>>>ENT FIRE AT (SKIPCOMPLETION) END: "+val.entity+":"+val.input)
						EntFire(val.entity,val.input,val.parameter,val.delay)
					}
				}
			}
		}
	}
}	


function PlayNextScene()
{
	local team = owninginstance.GetTeam()
	local inst = FindSceneInstanceByTeam(team)
	if (inst != null)
	{
		printldebug("========PLAYNEXTSCENE CALLING ENTITY: "+findIndex(owninginstance.GetTeam())+" : TIME "+Time())
		inst.deleteFiredVcd(team)
		inst.waitVcdCurrent = findIndex(team)
		PlayNextSceneInternal(inst)
	}	
	else
	{
		printldebug("========PLAYNEXTSCENE CALLING ENTITY NO LONGER EXISTS: CHECKING QUEUE...")
		QueueCheck()
	}
	
	if (waitEntityFire != null)
	{
		//printl("===================" + waitEntityFire+ " "+waitEntityInput+" "+waitEntityDelay)
		if (waitEntityParm != null)
			EntFire(waitEntityFire,waitEntityInput,waitEntityParm, waitEntityDelay)
		else
			EntFire(waitEntityFire,waitEntityInput,"", waitEntityDelay)
		waitEntityFire = null
		waitEntityInput = null
		waitEntityDelay = null
		waitEntityParm = null
	}
}	



function PlayNextSceneInternal(inst = null)
//inst = just completed scene
{
	local i = 0
	local tmp = 0

	//Set the ducking back to the default value
	SendToConsole( "snd_ducktovolume 0.55" )
	
	//Are there any "fire at the end" triggers associated with the just completed?
	if (inst.waitVcdCurrent != null)
	{
		if ("fires" in SceneTable[inst.waitVcdCurrent])
		{
			local idx, val
			foreach (idx, val in SceneTable[inst.waitVcdCurrent].fires)
			{
				if (!("fireatstart" in val))
				{
					printldebug(">>>>>>ENT FIRE AT END: "+val.entity+":"+val.input)
					EntFire(val.entity,val.input,val.parameter,val.delay)
				}
			}
		}
	}
	
	//If the vcd that's ending is part of a nag cycle, check to see if there are any queued
	//scenes for the primary nag character. If so, abandon the nag and start the queued scene.
	if (inst.isNag) 
	{
		if (QueueLen(inst.currentCharacter)>0)
		{
			printldebug("========ABANDONING NAG CYCLE TO PLAY QUEUED SCENE")
			scenequeue_DeleteScene(inst.index)
			QueueCheck()
			return
		}	
	}
	
	//Is there another vcd in the scene chain?
	if (inst.waitNext != null)
	{
		printldebug("=====There is a next scene: "+inst.waitNext)
		if (inst.waitLength == null)
		{
			i+=1
			printldebug("===================Ready to play:" + i)
			PlayVcd(inst)
 		}	
		else
		{
			inst.waitStartTime = Time()
			inst.waiting = 1
		}	
	}
	else
	{
		printldebug("=====No next scene!")
		//Remove the instance from the scene list
		scenequeue_DeleteScene(inst.index)
		//The current scene is over. Check to see if there are any queued scenes.
		if (QueueCheck())
			return
		//Do the ding if nothing's queued and the previous scene requires a ding
		if (!inst.waitNoDingOff)
			EntFireByHandle( sceneDingOff, "Start", "", 0.1, null, null )
	}
}


//Think function
function RadioVoiceThink()
{
	local curTime=Time()
	local thinkInterval = curTime-lastthink
	lastthink = curTime
	//Put debug stuff here!
	if (debug)
	{
		if (Time()-lastthink>debugInterval)
		{
			printldebug("===================RadioVoiceThink-> " + lastthink)
			lastthink = Time()
			QueueDebug()
		}
	}	
	
	if (m_GunTestStart==1 && m_GunTestComplete==0)
	{
			if (i_GunTestInterval==0)
			{
				i_GunTestInterval=Time()
			}
			if (curTime-i_GunTestInterval>30 && m_PlayedGunTestWaiting==0)
			{
				i_GunTestInterval=Time()
				m_PlayedGunTestWaiting=1
				GunTestWaiting()
			}
			if (curTime-i_GunTestInterval>25 && m_PlayedGunTestWaiting==1)
			{
				i_GunTestInterval=Time()
				m_PlayedGunTestWaiting=2
				GunTestWaiting2()
			}
	}

	if (m_IdTestStart==1 && m_IdTestComplete==0)
	{
			if (i_IdTestInterval==0)
			{
				i_IdTestInterval=Time()
			}
			if (curTime-i_IdTestInterval>60 && m_PlayedIdTestWaiting==0)
			{
				m_PlayedIdTestWaiting=1
				IdTestWaiting()
			}

	}

	local idx, val
	//scan the list of currently playing scenes.
	foreach (idx,val in scenequeue)
	{
		//Check if the current vcd is scheduled to exit early
		if (val.waitPreDelayed)
		{
			if (Time()>=val.waitDelayingUntil)
			{
				printldebug("*******LAUNCHING PREDELAYED SCENE")
				PlayVcd(val)
			}
		}
		if (val.waitExitingEarly)
		{
			if (Time()-val.waitExitingEarlyStartTime >= val.waitExitingEarlyThreshold)
			{
				local team
				val.waitExitingEarly=false
				local curscene = characterCurscene(val.currentCharacter)
				if (curscene!=null)
				{
					curscene.ValidateScriptScope()
					curscene.GetScriptScope().SkipOnCompletion <- SkipOnCompletion.bindenv(this)
					curscene.DisconnectOutput("OnCompletion", "PlayNextScene")
					curscene.DisconnectOutput("OnCompletion", "SkipOnCompletion")
					curscene.ConnectOutput( "OnCompletion", "SkipOnCompletion" )
					team = curscene.GetTeam()
					val.waitVcdCurrent = findIndex(team)
				}
				printldebug("====Scene "+val.index+" EXITING EARLY")
				PlayNextSceneInternal(val)
				return
			}
		}
	}
	
	local tmp
	//Check the deferred scene queue
	tmp = QueueThink()
	//Is a queued scene ready to fire?
	if (tmp != null)
	{
			printldebug("===========FORCING QUEUED SCENE: "+tmp)
			PlayVcd(tmp,true)
			return
	}

	foreach (idx,val in scenequeue)
	{
		//Are we waiting to play another vcd?
		if (val.waiting == 1)
		{
			if (Time()-val.waitStartTime >= val.waitLength)
			{
				val.waiting = 0
				PlayVcd(val)
			}
		}
	}
}


//Play a vcd from the SceneTable, plus set up next line (if any).
//This is the function that should be used to start a scene from inside a map.
function PlayVcd(arg,IgnoreQueue = null, caller = null )
//arg==instance	-> Continue playing scene defined by scene class instance arg
//arg==integer	-> Start playing new scene (scene being a chain of vcds) from SceneTable[SceneTableLookup[arg]]
//arg==string		-> Start playing new scene (scene being a chain of vcds) from SceneTable[arg]
//arg==null			-> Continue playing current scene with next vcd in current chain
//IgnoreQueue		-> true == don't check for queue status (this is used to force a queued vcd to play)
//caller				-> If passed as an entity, the vcd will have its "target1" set to caller.GetName()
//NoSkip 				-> If set to true will not allow another vcd to play until the first is completed.  Not added yet
{
	printldebug("=========PlayVcd Called!========="+arg)	
	local dingon = false
	
	local inst
	local fromqueue = firedfromqueue
	firedfromqueue = false
	
	if (typeof arg == "instance")
	{
		//if this is a vcd that was being held for predelay, play it
		if (arg.waitPreDelayed)
		{
			inst = arg
			arg = inst.waitPreDelayedEntry
		}
		//otherwise, play the next vcd in the chain
		else
		{
			inst = arg
			arg=inst.waitNext
		}	
	}
	else
	{
		//If this is a call from the map, look up the integer arg in the scene lookup table.
		//We need to do this because hammer/the engine can't pass a squirrel script a string, just an integer.
		//In other words, from a map, @radiovoice.PlayVcd("MyVcd") crashes the game. PlayVcd(16) doesn't.
		local sceneStart = 0
		if (typeof arg == "integer")
		{
			if (arg == 407 || arg == 43) //remove this line without changing map (12/21/2010)
			{
				return
			}
			sceneStart = arg
			printldebug("{}{}{}{}{}{}{}{}{}PlayVcd: "+arg)	
			arg = SceneTableLookup[arg]
		}
		else
		{
			sceneStart = 0
		}
		
		//if there is an uninterruptible scene already playing for this character, skip the new scene
		if (IsCharPlayingUninterruptibleScene(SceneTable[arg].char))
		{
			printl("** Scene " + sceneStart + " trying to stomp on currently playing scene, which is flagged 'uninterruptible'. Ignoring." )
			return
		}
			
		//if SkipIfBusy is present & we're already playing a scene, skip this new scene
		if ("skipifbusy" in SceneTable[arg])
		{
			if (characterCurscene(SceneTable[arg].char)!=null)
			{
				return
			}
		}
		//if queue is present & we're already playing a scene, add scene to queue
 		if ("queue" in SceneTable[arg])
	 	{
	 		if (IgnoreQueue == null)
			{
				//queue if a specific character is talking 
		 		if ("queuecharacter" in SceneTable[arg])
		 		{
					if (characterCurscene(SceneTable[arg].queuecharacter)!=null)
					{
				 		QueueAdd(arg)
			 			return
			 		}
				}
				//otherwise, queue if the character associated with the vcd is talking
				else
				{
					if (characterCurscene(SceneTable[arg].char)!=null)
					{
				 		QueueAdd(arg)
			 			return
			 		}
			 	}	
			}		
	  }
	  
		if (scenequeue_AddScene(arg,SceneTable[arg].char) == null)
			return
		inst = scenequeue[arg]
		inst.waitSceneStart = sceneStart
		
		if ("idle" in SceneTable[arg])
		{
			nags_init(inst,arg)
		}
		
		//is this scene tagged uninterruptible?
		if ("uninterruptible" in SceneTable[arg])
		{
			if( SceneTable[arg].uninterruptible == true )
			{
				inst.waitUninterruptible = true
			}
		}


		//This is a new dialog block, so turn off special processing
		dingon=false
		inst.waitNoDingOff = true
		inst.waitNoDingOn = true
	}
	
	local preDelay = 0.00
	//If this vcd wasn't called after a predelay (meaning the predelay already happened), see if there is a predelay
	if (!inst.waitPreDelayed)
	{
		preDelay = EvaluateTimeKey("predelay", SceneTable[arg])
		if (fromqueue && "queuepredelay" in SceneTable[arg])
		{
			preDelay = EvaluateTimeKey("queuepredelay", SceneTable[arg])
		}
		//If there is a predelay, set it and then radiovoiceThink() will fire it after predelay seconds.
		if (preDelay > 0.00)
		{
			inst.waitPreDelayed = true
			inst.waitDelayingUntil = Time()+preDelay
			inst.waitPreDelayedEntry = arg
			printldebug("======= "+arg+" PREDELAYED FOR "+preDelay+" SECONDS")
			return
		}
	}
	//Otherwise, set the PreDelayed flag to false	
	else
	{
		inst.waitPreDelayed = false
		inst.waitPreDelayedEntry = null
	}
	
	//If this scene is a nag/idle cycle, grab the next line off the stack
	if (inst.isNag)
	{
		//If we're not in a vcd chain, grab the next vcd from the randomized pool
		if (!inst.naginchain)
		{
			arg = nags_fetch(inst)
		}	
		//if nothing fetched (because the nag has used all the lines and isn't marked as "repeat"), remove this scene
		if (arg == null)
		{
			scenequeue_DeleteScene(inst.index)
			return
		}
	}
	
	//Set ducking volume correctly for booming audio
	//SendToConsole( "snd_ducktovolume 0.2" )
  //SetDucking( "announcerVOLayer", "announcerVO", 0.01 ) 
  //SetDucking( "VOLayer", "VO", 0.1 ) 

	if ( arg != null )
	{

		local ltalkover
		ltalkover =  "talkover" in SceneTable[arg]

		//Cancel any vcd that's already playing
		if (!ltalkover)
		{
			AllCharactersStopScene()
		}	
		else
		{
			//characters can't currently talk over themselves
			CharacterStopScene(SceneTable[arg].char)
		}
		
		//Play the initial ding (unless the scene specifically requests no ding)
		if (dingon && !inst.waitNoDingOn)
			EntFireByHandle( sceneDingOn, "Start", "", 0.00, null, null )

		
		//Start the new vcd	
		printldebug("===================Playing:" + arg)
		inst.currentCharacter = SceneTable[arg].char
		
		//Bind the OnCompletion Event
		SceneTable[arg].vcd.ValidateScriptScope()
		SceneTable[arg].vcd.GetScriptScope().PlayNextScene <- PlayNextScene.bindenv(this)
		SceneTable[arg].vcd.DisconnectOutput( "OnCompletion", "PlayNextScene" )
		SceneTable[arg].vcd.ConnectOutput( "OnCompletion", "PlayNextScene" )
		SceneTable[arg].vcd.ConnectOutput( "OnCanceled", "SceneCanceled" )
		
		//Set the target1 if necessary
		if (caller != null)
		{
			if (typeof caller == "string")
			{
				EntFireByHandle( SceneTable[arg].vcd, "SetTarget1", caller, 0, null, null )
				printldebug("++++++++++++SETTING TARGET: "+caller)
			}	
			else
			{
				EntFireByHandle( SceneTable[arg].vcd, "SetTarget1", caller.GetName(), 0, null, null )
			}
		}	
		if ("settarget1" in SceneTable[arg])
		{
			printldebug("++++++++++++ "+arg+"SETTING TARGET: "+SceneTable[arg].settarget1)
			EntFireByHandle( SceneTable[arg].vcd, "SetTarget1", SceneTable[arg].settarget1 , 0, null, null )
		}

		inst.waitVcdTeam = SceneTable[arg].index
		inst.waitVcdCurrent = arg
		
		inst.addFiredVcd(SceneTable[arg].index)
				
		if (dingon && !inst.waitNoDingOn)
			EntFireByHandle( SceneTable[arg].vcd, "Start", "", 0.00+0.18, null, null )
		else	
			EntFireByHandle( SceneTable[arg].vcd, "Start", "", 0.00, null, null )

		
		//Does this vcd have a "fire into entities" array?
		if ("fires" in SceneTable[arg])
		{
			local idx, val
			foreach (idx, val in SceneTable[arg].fires)
			{
				if ("fireatstart" in val)
				{
					printldebug(">>>>>>ENT FIRE AT START: "+val.entity+":"+val.input)
					EntFire(val.entity,val.input,val.parameter, val.delay)
				}
			}
		}


		//Setup next line (if there is one)
		if (SceneTable[arg].next != null || inst.isNag)
		{
    		local pdelay = EvaluateTimeKey("postdelay",SceneTable[arg])
    	
    		//if this is a nag, use min/max defined in the first entry in the scene
    		if (inst.isNag)
    		{
    			pdelay = RandomFloat(inst.nagminsecs,inst.nagmaxsecs)
    		}

    		if (pdelay<0.00)
    		{
    			if (inst.isNag)
    				//If the "next" key != null, it means we're in a vcd chain
    				if (SceneTable[arg].next != null)
    				{
    					inst.waitNext = SceneTable[arg].next
    					inst.naginchain = true
    				}
    				else
    				{
    					//Otherwise, just slug in the same index (any non-null value would work here, however)
							inst.waitNext = arg
    					inst.naginchain = false
						}
    			else
						inst.waitNext = SceneTable[arg].next 
 					inst.waitExitingEarly=true
 					inst.waitLength=null
 					inst.waitExitingEarlyStartTime=Time()
					//If we're in a nag vcd chain, use the vcds postdelay rather than the nag-wide delay
					//This is because vcd chains generally need to be explicitly timed at the chain level
					//since the vcds are grouped together as a block
 					if (inst.naginchain)
 						pdelay = EvaluateTimeKey("postdelay",SceneTable[arg])
 					inst.waitExitingEarlyThreshold=pdelay*-1
				}
				else
				{
 					inst.waitExitingEarly=false
    			if (inst.isNag)
    			{
    				//If the "next" key != null, it means we're in a vcd chain
    				if (SceneTable[arg].next != null)
    				{
    					inst.waitNext = SceneTable[arg].next
    					inst.naginchain = true
    				}
    				else
    				{
    					//Otherwise, just slug in the same index (any non-null value would work here, however)
							inst.waitNext = arg
    					inst.naginchain = false
						}
					}
    			else
    			{
						inst.waitNext = SceneTable[arg].next 
					}	
					//If we're in a nag vcd chain, use the vcds postdelay rather than the nag-wide delay
					//This is because vcd chains generally need to be explicitly timed at the chain level
					//since the vcds are grouped together as a block
 					if (inst.naginchain)
 						pdelay = EvaluateTimeKey("postdelay",SceneTable[arg])
				}	
   			inst.waitLength = pdelay
		}	
		else
		{
			inst.waitNext = null
			printldebug("===================SCENE END")
		}

		//Check for EntFire at end of vcd
		if ("fireentity" in SceneTable[arg])
		{
			printl( "adding "+SceneTable[arg].fireentity+" to waitEntityFire" );
			waitEntityFire = SceneTable[arg].fireentity
			waitEntityInput = SceneTable[arg].fireinput
			waitEntityDelay = SceneTable[arg].firedelay
			waitEntityParm = null
			if ("fireparm" in SceneTable[arg])
				waitEntityParm = SceneTable[arg].fireparm
		}
		else
		{
			waitEntityFire = null
			waitEntityInput = null
			waitEntityDelay = null
			waitEntityParm = null
		}
		//Check for any special end-of-vcd processing
		if ("endspecial" in SceneTable[arg]) 
			waitEndSpecial = SceneTable[arg].endspecial
		else 
			waitEndSpecial = 0

	}	
}

function EvaluateTimeKey(keyname, keytable)
{
	local ret = null

 	if (keyname in keytable)
 	{
 		local typ = typeof keytable[keyname]
 		if (typ == "array")
 		{
 			if (keytable[keyname].len() != 2)
 			{
				printldebug("!!!!!!!!!!!!EVALUATE TIME KEY ERROR: "+keyname+" is an array with a length != 2") 		
				return 0.00
 			}
	 		ret = RandomFloat(keytable[keyname][0],keytable[keyname][1])
	 	}
	 	else
	 	{
	 		ret = keytable[keyname]
	 	}	
 	}
 	if (ret == null)
 		ret = 0.00
	printldebug(">>>>>>>>>EVALUATE TIME KEY: "+keyname+" : "+ret) 		
 	return ret
}


function ToggleDebug(arg = null)
{
	debug = !debug
	if (debug)
		printl("====================== debug ON")
	else
		printl("====================== debug OFF")
	if (arg!=null)
		debugInterval = arg
}

//Nukes Everything. Delete all currently playing & queued scenes.
function nuke()
{
	scenequeue = {}
	Queue.clear()
	AllCharactersStopScene()
	StopAllCaveSpeakers()
	
}


//Stops a scene for all characters
function AllCharactersStopScene()
{
	CharacterStopScene("radiovoice")
}

function characterCurscene(arg)
{
	local ret = null, ent = null
	switch (arg)
	{
		case "radiovoice":
			ent = Entities.FindByName(ent, "@radiovoice")
			break
		case "valeria":
			ent = Entities.FindByName(ent, "@valeria")
			break
	}
	if (ent != null)
	{
		printldebug("&&&&&&FOUND ENTITY: "+arg)
		ret = ent.GetCurrentScene()
	}	
	else
	{
		printldebug("!!!!!!!!!!!!ENTITY NOT FOUND: "+arg)
	}
	return ret
}

//Stops a scene for a particular character
function CharacterStopScene(arg)
{
	local ent = null
	local curscene = characterCurscene(arg)
	if ( curscene != null )
	{
		printldebug("&&&&&&STOP SCENE: "+arg+" FOUND SCENE TO DELETE!!!!!!!!!")
		EntFireByHandle( curscene, "Cancel", "", 0, null, null )
	}
	else
	{
		printldebug("&&&&&&STOP SCENE: NO SCENE TO DELETE FOR " + arg)
	}
}

//Turns off current speech
function StopTalking()
{
	local curscene = self.GetCurrentScene()
	waitNext = null
	waitLength = null
	if ( curscene != null )	
			EntFireByHandle( curscene, "Cancel", "", 0, null, null )
}

//Turns off current speech if the scene # passed as arg is currently playing
function StopScene(arg)
{
	if (waitSceneStart == arg)
	{ 
		local curscene = self.GetCurrentScene()
		waiting = 0
		waitNext = null
		waitLength = null
		if ( curscene != null )	
			EntFireByHandle( curscene, "Cancel", "", 0, null, null )
	}		
}


//--------------------------------------------------------------------------------------------------------------
//Queue Functions
//	-This is the queue of scenes delayed by another scene
//--------------------------------------------------------------------------------------------------------------

Queue <- []

//Initialize the queue
function QueueInitialize()
{
	Queue.clear()
}

//Add a scene to the queue
//Queue table structure:
//	item 						= index in SceneTable (ie: SceneTable[Queue[index].item])
//	added						= time added to queue
//	queueforcesecs	= (from SceneTable) force item to play after queueforcesecs seconds in queue
//	queuetimeout		= (from SceneTable) delete item if it sits in queue for queuetimeout seconds
//	queuepredelay		= (from SceneTable) wait queuepredelay seconds to fire the scene if it sat in the queue for any amount of time
function QueueAdd(arg)
{
	Queue.append( { item = arg added = Time() })
	if (arg in SceneTable)
	{
 		if ("queueforcesecs" in SceneTable[arg])
 		{
 			Queue[Queue.len()-1].queueforcesecs <- SceneTable[arg].queueforcesecs
 		}
 		else
 		{
 			Queue[Queue.len()-1].queueforcesecs <- 45.0
 		}
 		if ("queuetimeout" in SceneTable[arg])
 		{
 			Queue[Queue.len()-1].queuetimeout <- SceneTable[arg].queuetimeout
 		}
 		if ("queuepredelay" in SceneTable[arg])
 		{
 			Queue[Queue.len()-1].queuepredelay <- SceneTable[arg].queuepredelay
 		}

	}
}

//Returns number of items in the queue
function QueueLen(char = null)
{
	local i = 0
	if (char == null)
	{
		return Queue.len()
	}	
	else
	{
		foreach (index, scene in Queue)
		{
			if (SceneTable[scene.item].char == char)
			{
				i+=1
			}
		}
		return i
	}
}

//Fetch the next scene in the queue
function QueueGetNext()
{
	local ret,l
	ret = null
	l=QueueLen()
	if (l>0)
	{
		ret = Queue[l-1].item
		Queue.remove(l-1)
	}
	return ret
}

function QueueDebug()
{
	printldebug("===================  items in queue-> " + Queue.len())
	foreach (index, scene in Queue)
	{
		printldebug("========= queue item "+index+"("+scene.item+"): character "+SceneTable[scene.item].char)
	}
}

//General stuff called from RadioVoiceThink()
function QueueThink()
{
	local ret,t,index
	if (QueueLen()==0)
	{
		return null
	}	
	
	t=Time()
	//Check to see if any queued scenes timed out
	for (index = QueueLen(); index > 0; index -= 1)
	{
 		if ("queuetimeout" in Queue[index-1])
 		{
 			if (t-Queue[index-1].added > Queue[index-1].queuetimeout)
 			{
 				Queue.remove(index-1)
 			}
 		}
	}

	//Check to see if any queued scenes should force fire
	foreach (index, scene in Queue)
	{
 		if ("queueforcesecs" in scene)
 		{
 			if (t-scene.added >scene.queueforcesecs)
 			{
 				ret = scene.item
 				Queue.remove(index)
 				return ret
 			}
 		}
	}
	return null
}

//Debug testbed function
function QueueTest()
{
	local a = []
	for(local i=0;i<10;i+=1)
	{
		a.append(RandomInt(1,100))
		printl(">>>>>> " + i + " : " + a[i])
	}
	for (local i = a.len(); i>0; i-=1)
	{
		if (a[i-1]<50)
			a.remove(i-1)
	}
	foreach (index, n in a)
	{
		printl(">>>>>> " + index + " : " + a[index])
	}
}

//Delete a single item from the queue
function QueueDeleteItem(item)
{
	if (QueueLen()==0)
	{
		return false
	}	
	foreach (index, scene in Queue)
	{
		if (scene.item == item)
		{
 				Queue.remove(index)
 				return true
 		}
	}
	return false
}


//Check to see if there's a Queued scene ready to go. If so, fire it! (and return true)
function QueueCheck()
{
	local tmp
	if (QueueLen()>0)
	{
		printldebug("===QUEUE LEN IS "+QueueLen())
		tmp=QueueGetNext()
		if (tmp != null)
		{
			firedfromqueue = true
			PlayVcd(tmp,true)
			//PlayVcd(tmp)
			return true
		}
	}
	return false
}

//--------------------------------------------------------------------------------------------------------------
//End of Queue Functions
//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------
//Scenes List Functions START
//	-This is the list of currently playing scenes
//--------------------------------------------------------------------------------------------------------------

class scene {
	//constructor
	constructor(a, caller)
	{
		index = a
		owner = caller
		currentCharacter = ""
		waitSceneStart = 0 //1 means we're waiting for the current vcd to finish so we can play the next vcd in the chain
		waiting = 0  
		waitVcdCurrent = null
		waitStartTime = Time()
		waitLength = Time()
		waitNext = null 
		waitExitingEarly = false 
		waitExitingEarlyStartTime = Time() 
		waitExitingEarlyThreshold = 0.00 //How many seconds sould the VCD play before moving on to the next one
		waitDelayingUntil = null
		waitPreDelayed = false
		waitPreDelayedEntry = null
		waitNoDingOff = false
		waitNoDingOn = false
		waitVcdTeam = -1
		waitFiredVcds = []
		waitUninterruptible = false
		nagminsecs = 0
		nagmaxsecs = 0
		nags = []
		isNag = false
		nagpool = []
		naglastfetched = null
		nagrandom = false
		nagrandomonrepeat = false
		nagtimeslistcompleted = 0
		nagrepeat = false
		naginchain = false
	}
	
	function nagsClear()
	{
		naglastfetched = null
		nags.clear()
	}
	
	function nagpoolClear()
	{
		nagpool.clear()
	}


	function addFiredVcd(team)
	{
		waitFiredVcds.append(team)
	}

	function deleteFiredVcd(team)
	{
		local idx, val
		local fnd = null
		foreach (idx, val in waitFiredVcds)
		{
			if (val == team)
			{
				fnd = idx
				break
			}
		}	
		if (fnd != null)
		{
			waitFiredVcds.remove(fnd)
		}
	}

	
	//property
	index = 0;
	owner = null;
	currentCharacter = "";
	waitSceneStart = 0; //1 means we're waiting for the current vcd to finish so we can play the next vcd in the chain
	waiting = 0;  
	waitVcdCurrent = null; //SceneTable index of last launched vcd
	waitStartTime = 0;
	waitLength = 0;
	waitNext = null; 
	waitExitingEarly = false; 
	waitExitingEarlyStartTime = 0; 
	waitExitingEarlyThreshold = 0.00; //How many seconds sould the VCD play before moving on to the next one
	waitDelayingUntil = null;
	waitPreDelayed = false;
	waitPreDelayedEntry = null;
	waitNoDingOff = false;
	waitNoDingOn = false;
	waitFires = [];
	waitVcdTeam = -1;
	waitFiredVcds = [];
	waitUninterruptible = false;	
	isNag = false;
	nags = [];
	nagpool = [];
	nagminsecs = 0;
	nagmaxsecs = 0;
	naglastfetched = null;
	nagrandom = false;
	nagrandomonrepeat = false;
	nagtimeslistcompleted = 0;
	nagrepeat = false;
	naginchain = false;
}


function scenequeue_AddScene(arg,char)
{
	local idx, val,delme
	delme=null
	foreach (idx, val in scenequeue)
	{
		if (SceneTable[idx].char==char)
		{
			delme = idx
		}
		if (idx == arg)
		{
			printldebug(">>>>>>>>>>Scene "+arg+" is already in the queue")
			return null
		}
	}
	if (delme != null)
	{
		printldebug(">>>>>>>>>>DELETING SCENE "+delme)
		scenequeue_DeleteScene(delme)
	}
	scenequeue[arg] <- scene(arg, this)
	scenequeue_Dump()
	return scenequeue[arg]
}

function scenequeue_DeleteScene(arg)
{
	local idx, val
	foreach (idx, val in scenequeue)
	{
		if (idx == arg)
		{
			printldebug(">>>>>>>>>>Scene "+arg+" deleted!")
			delete scenequeue[arg]
			return true
		}
	}
	return null
}

function scenequeue_Dump()
{
	
	printldebug(">>>>>>>>>>Scene Dump at "+Time())
	foreach (idx, val in scenequeue)
	{
		printldebug(">>>>>>>>>>Scene "+idx+" ADDED at "+val.waitStartTime+" Type "+ typeof val)
	}	
}

//--------------------------------------------------------------------------------------------------------------
//Scene Queue Functions END
//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------
//Nag Table Functions START
//--------------------------------------------------------------------------------------------------------------

function nags_init(inst,scenetableentry)
{
	local i = 0
	inst.nagsClear()
	if ("idleminsecs" in SceneTable[scenetableentry])
	{
		inst.nagminsecs = SceneTable[scenetableentry].idleminsecs
		if ("idlemaxsecs" in SceneTable[scenetableentry])
		{
			inst.nagmaxsecs = SceneTable[scenetableentry].idlemaxsecs
		}
		else
		{
			inst.nagmaxsecs = inst.nagminsecs
		}
	}
	
	if ("idlerandomonrepeat" in SceneTable[scenetableentry])
	{
		inst.nagrandomonrepeat = true
	}
	
	if ("idlerepeat" in SceneTable[scenetableentry])
	{
		inst.nagrepeat = true
	}

	if ("idlerandom" in SceneTable[scenetableentry])
	{
		inst.nagrandom = true
	}

	local igroup = SceneTable[scenetableentry].idlegroup
	local idx, val,oig=0
	foreach (idx, val in SceneTable)
	{
		if (!("idlegroup" in val))
			continue
		if (val.idlegroup != igroup)
			continue
		local rar = 101, mnum = 0
		if ("idlerarity" in val)
		{
			rar = val.idlerarity
		}
		if ("idlemaxplays" in val)
		{
			mnum = val.idlemaxplays
		}
		//Skip vcds that are part of a chain (and not the first link in the chain)
		if ("idleunder" in val)
		{
			continue
		}
		if ("idleorderingroup" in val)
		{
			oig=val.idleorderingroup
		}
		else
		{
			oig=0
		}
		inst.nags.append({SceneTableIndex=idx, rarity = rar, maxplays = mnum, totplays = 0,orderingroup = oig})
	}
	inst.nags.sort(nag_array_compare)
	inst.isNag = true
	inst.nagtimeslistcompleted = 0
	nags_createpool(inst)
}

function nags_createpool(inst)
{
	inst.nagpoolClear()
	local idx, val
	local takeit = false
	local tempa = []
	foreach (idx, val in inst.nags)
	{
		takeit=false
		if (val.totplays >= val.maxplays && val.maxplays>0)
		{
			continue
		}
		if (RandomInt(1,100)<val.rarity)
		{
			takeit=true
		}	
		if (takeit)
		{
			tempa.append(val)
		}
	}
	local r
	//The pool can still be empty at this point if only rare lines were available and none of them "made their roll".
	if (tempa.len() == 0)
		return
	
	if (inst.nagrandom || (inst.nagrandomonrepeat && inst.nagtimeslistcompleted > 0))
	{
		//Make sure the first entry in the new list isn't the same as the last vcd played.
		//This ensures no repeats.
		if (tempa.len()>1 && inst.naglastfetched!=null)
		{
			while (true) 
			{
				r=RandomInt(0,tempa.len()-1)
				if (tempa[r].SceneTableIndex != inst.naglastfetched)
				{
					inst.nagpool.append(tempa[r])
					tempa.remove(r)
					break
				}
			}
		}
		//Now build the rest of the pool
		while (tempa.len()>0)
		{
			r=RandomInt(0,tempa.len()-1)
			inst.nagpool.append(tempa[r])
			tempa.remove(r)
		}
	}
	else
	{
		foreach(idx, val in tempa)
		{
			inst.nagpool.append(val)
		}
	}	
}

function nags_nagpooldump(inst)
{
	local idx, val
	foreach (idx, val in inst.nagpool)
		printldebug("*********NAG "+idx+" : "+val.SceneTableIndex)
}

function nags_fetch(inst)
{
	if (inst.nagpool.len() == 0)
	{
		if (inst.nagrepeat)
		{
			inst.nagtimeslistcompleted += 1
			nags_createpool(inst)
			if (inst.nagpool.len() == 0)
				return null
		}
		else
		{
			return null
		}	
	}
	local ret = inst.nagpool[0].SceneTableIndex
	foreach( idx, val in inst.nags)
	{
		if (val.SceneTableIndex == ret)
		{
			val.totplays+=1
			break
		}
	}
	//nags_nagpooldump(inst)
	inst.nagpool.remove(0)
	inst.naglastfetched = ret
	return ret
}

function StopNag(arg = 0)
{
	nag_stop("glados",arg)
}

function WheatleyStopNag(arg = 0)
{
	nag_stop("wheatley",arg)
}

function Core01StopNag(arg = 0)
{
	nag_stop("core01",arg)
}

function Core02StopNag(arg = 0)
{
	nag_stop("core02",arg)
}

function Core03StopNag(arg = 0)
{
	nag_stop("core03",arg)
}


function nag_stop(char, stoptype)
{
	local idx, val
	local todel = null
	foreach (idx, val in scenequeue)
	{
		if (val.isNag && val.currentCharacter == char)
		{
			todel=idx
			break
		}
	}
	if (todel != null)
	{
		scenequeue_DeleteScene(todel)	
	}
}

function nag_array_compare(a,b)
{
	if(a.orderingroup>b.orderingroup) return 1
	else if(a.orderingroup<b.orderingroup) return -1
	return 0;
}


//--------------------------------------------------------------------------------------------------------------
//Nag Table Functions END
//--------------------------------------------------------------------------------------------------------------



//------------------------------------------------------------------------------------------------------------
//START OF EXISTING RADIOVOICE!!!!!	
//------------------------------------------------------------------------------------------------------------
//Next VCD in scene chain info
	waitSceneStart <- 0
	waiting <- 0  //1 means we're waiting for the current vcd to finish so we can play the next vcd in the chain
	waitStartTime <- Time()
	waitLength <- Time()
	waitNext <- null //the SceneTable id for the next scene in the current chain.
	waitNoDingOff <- false
	waitNoDingOn <- false
	waitEndSpecial <- 0
	waitEntityFire <- null
	waitEntityInput <- null
	waitEntityParm <- null
	waitEntityDelay <- null
//debug stuff
	//debug <- true	//Set true to enable debug block during think function
	//debugInterval <- 2.00
	debugAccrued <- 0.00
	debugMicTest <- false
//Misc
	SayOnSilence <- 0 //if >0: When SilenceTicks>=Silencethreshold, RadioVoicePlayVcd(SayOnSilence)

//Test stuff
	m_PlayingFailure <-0
	m_GunTestStart <- 0
	m_GunTestComplete <- 0
	m_PlayedGunTestWaiting <- 0
	i_GunTestInterval  <- 0

	m_IdTestStart  <- 0
	m_IdTestComplete  <- 0
	m_PlayedIdTestWaiting <- 0
	i_IdTestInterval   <- 0

	i_LocationDamage <- 0
	
	i_saidFireDamage <- Time()
	i_HeadDamageCounter <- 1
	i_ChestDamageCounter <- 1
	i_LegDamageCounter <- 1
	i_FriendlyFireCounter <- 1
	i_FriendlyFire <- Time()
	m_StartedTimedCourse <-0
	i_FailureAmmoCount <-0
	m_BurstTestStarted <- 0
	m_BurstBlockerTestStarted <-0
	m_CrouchTestStarted <- 0
	i_BodyDamageFailCount <-0
	m_GrenadeHitCagedDone <- 0
	i_GrenadeHitCounter <-0
	i_FlashBangFlashedCounter <-0
	i_FlashBangFailedTargets <-0
	m_BombPlantA <- 0
	m_BombBeingDefused <-0
	m_ReturnVisitor <-0 

function RadioVoiceThinkOriginal()
{
	local curTime=Time()
	local thinkInterval = curTime-lastthink
	lastthink = curTime
	//Put debug stuff here!
	if (debug)
	{
		debugAccrued += thinkInterval
		if (debugAccrued>debugInterval)
		{
			debugAccrued = 0
			printl("===================RadioVoiceNEWThink-> " + lastthink+" "+thinkInterval)
		}
	}
	if (m_GunTestStart==1 && m_GunTestComplete==0)
	{
			if (i_GunTestInterval==0)
			{
				i_GunTestInterval=Time()
			}
			if (curTime-i_GunTestInterval>30 && m_PlayedGunTestWaiting==0)
			{
				i_GunTestInterval=Time()
				m_PlayedGunTestWaiting=1
				GunTestWaiting()
			}
			if (curTime-i_GunTestInterval>10 && m_PlayedGunTestWaiting==1)
			{
				i_GunTestInterval=Time()
				m_PlayedGunTestWaiting=2
				GunTestWaiting2()
			}


	}

	if (m_IdTestStart==1 && m_IdTestComplete==0)
	{
			if (i_IdTestInterval==0)
			{
				i_IdTestInterval=Time()
			}
			if (curTime-i_IdTestInterval>60 && m_PlayedIdTestWaiting==0)
			{
				m_PlayedIdTestWaiting=1
				IdTestWaiting()
			}

	}

	//Wait for a break in the player's talking to say a line
	if (SayOnSilence)
	{
		local OrangeIndex = GetOrangePlayerIndex()
		local BlueIndex = GetBluePlayerIndex()
		
		local curscene = self.GetCurrentScene()
		if ( curscene == null )
		{
			EntFireByHandle(BlahVcds[RandomInt(1,8)], "Start", "", 0.00, null, null )
			SilenceBlahsPlayed += 1
		}
		local lSilence = true
		if (PlayerVoiceListener.IsPlayerSpeaking(OrangeIndex)) lSilence = false
		if (PlayerVoiceListener.IsPlayerSpeaking(BlueIndex)) lSilence = false
		if (lSilence)
			SilenceTicks += thinkInterval
		else
			SilenceTicks = 0
		if (SilenceTicks >= Silencethreshold || SilenceBlahsPlayed > 5)
		{
			local i = SayOnSilence
			SayOnSilence = 0
			RadioVoicePlayVcd(i)
		}		
	}
	//Are we waiting to play another vcd?
	if (waiting == 1)
	{
		if (Time()-waitStartTime >= waitLength)
		{
			waiting = 0
			RadioVoicePlayVcd(null)
		}
	}
}
	
//Play a vcd from the SceneTable, plus set up next line (if any)	
function RadioVoicePlayVcd(arg)
//arg==integer -> Start playing new scene (scene being a chain of vcds) from SceneTable[SceneTableLookup[arg]]
//arg==string  -> Start playing new scene (scene being a chain of vcds) from SceneTable[arg]
//arg==null    -> Continue playing current scene with next vcd in current chain
{
	local dingon = false
	if (arg == null)
	{
		arg=waitNext
	}
	else
	{
		//If this is a call from the map, look up the integer arg in the scene lookup table.
		//We need to do this because hammer/the engine can't pass a squirrel script a string, just an integer.
		if (typeof arg == "integer")
		{
			waitSceneStart = arg
			arg = SceneTableLookup[arg]
		}
		else
		{
			waitSceneStart = 0
		}
		//This is a new dialog block, so turn off special processing
		dingon=true
		startBlock = Time()
		if ("noDingOff" in SceneTable[arg])
			waitNoDingOff = true
		else
			waitNoDingOff = false	
		if ("noDingOn" in SceneTable[arg])
			waitNoDingOn = true
		else
			waitNoDingOn = false	
	}
	local preDelay = 0.00
	if ( arg != null )
	{
		if ("predelay" in SceneTable[arg])
			preDelay = SceneTable[arg].predelay
		//Cancel any vcd that's already playing
		local curscene = self.GetCurrentScene()
		if ( curscene != null )
		{
			EntFireByHandle( curscene, "Cancel", "", 0, null, null )
		}
		

		//Start the new vcd	
		if (dingon && !waitNoDingOn)
			EntFireByHandle( SceneTable[arg].vcd, "Start", "", 0.18, null, null )
		else	
			EntFireByHandle( SceneTable[arg].vcd, "Start", "", preDelay, null, null )

	}	
}

//Turns off current RadioVoice speech
function RadioVoiceStopTalking()
{
	local curscene = self.GetCurrentScene()
	waiting = 0
	waitNext = null
	waitLength = null
	//if ( curscene != null )	
	//		EntFireByHandle( curscene, "Cancel", "", 0, null, null )
}

//Turns off current RadioVoice speech if the scene # passed as arg is currently playing
function RadioVoiceStopScene(arg)
{
	if (waitSceneStart == arg)
	{ 
		local curscene = self.GetCurrentScene()
		waiting = 0
		waitNext = null
		waitLength = null
		if ( curscene != null )	
			EntFireByHandle( curscene, "Cancel", "", 0, null, null )
	}		
}



function MainIntro ( )
{
 //-----------------------------------------------------------------------------------------------	
 //I PUT THIS HERE TEMPORARILY BECAUSE ONPOSTSPAWN ISN'T FIRING AUTOMATICALLY LIKE IT SHOULD!!!!
 OnPostSpawn()
 //-----------------------------------------------------------------------------------------------	
 PlayVcd(37)
 printl("===================MainIntro!"+includeTestString+PostSpawnString)
 printl("===================MainIntro!"+includeTestString+PostSpawnString)
 printl("===================MainIntro!"+includeTestString+PostSpawnString)
 m_GunTestStart=1
}
function ReturnRandom( arg0,arg1,arg2,arg3,arg4,arg5){
	local pData = {};
	local pDataCount = 0
	if (arg0>0){
		pData[0] <- arg0
	}
	if (arg1>0){
		pData[1] <- arg1
		pDataCount=1
	}
	if (arg2>0){
		pData[2] <- arg2
		pDataCount=2
	}
	if (arg3>0){
		pData[3] <- arg3
		pDataCount=3
	}
	if (arg4>0){
		pData[4] <- arg4
		pDataCount=4
	}
	if (arg5>0){
		pData[5] <- arg5
		pDataCount=5
	}
	local rndpick = RandomInt(0,pDataCount)
	return pData[rndpick]
}
